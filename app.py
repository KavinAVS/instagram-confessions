from flask import Flask, render_template, request
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

from waitress import serve
import imageMaker.pil_autowrap as pilwrap
import logging
from decouple import config
from instagrapi import Client
import psycopg
import os

DATABASE_URL = config('DATABASE_URL')
INSTA_USER = config('INSTA_USER')
INSTA_PWD = config('INSTA_PWD')

logger = logging.getLogger('instagrapi')
logger.setLevel(logging.INFO)

app = Flask(__name__)
limiter = Limiter(get_remote_address, app=app)

# Login to DB
conn = psycopg.connect(DATABASE_URL)
with conn.cursor() as cur:
    cur.execute("""
        CREATE TABLE IF NOT EXISTS Posts (
            PostID INT GENERATED BY DEFAULT AS IDENTITY (INCREMENT 1 MINVALUE 0 START 0) PRIMARY KEY, 
            message STRING NOT NULL, 
            name STRING NOT NULL,
            reply_to INT REFERENCES Posts(PostID) ON DELETE SET NULL
        );
    """)
    conn.commit()

# Login to Instagram
cl = Client()
cl.login(INSTA_USER, INSTA_PWD)

@app.route('/', methods=["GET"])
def main():
    return render_template("index.html")


@app.route('/', methods=["POST"])
@limiter.limit("10/day")
def post():
    content = request.get_json(silent=True)
    
    if("message" not in content or content["message"] == ""):
        return {"ret": False, "error":"nomsg"}
    elif(len(content["message"]) > 800):
        return {"ret": False, "error":"msgtoolong"}
    
    if("name" not in content or content["name"] == ""):
        name = "Anon"
    elif(len(content["name"]) > 50):
        return {"ret": False, "error":"nametoolong"}
    else:
        name = content["name"]
        
    #add to DB
    print("Adding to DB..")
    try:
        with conn.cursor() as cur:
            cur.execute(f"INSERT INTO Posts (message, name, reply_to) VALUES ('{content['message']}', '{name}', NULL) RETURNING PostID;")
            res = cur.fetchall()
            conn.commit()
            post_num=res[0][0]
    except:
        print("Failed to add to db")
        return {"ret": False, "error":"dbwrite"}
    
    print("Added to DB, Making image..")
    
    #Make the image
    post_str=f"post#{post_num:05d}"
    try:
        pilwrap.make_text_image(content["message"], name, post_str, (55, 118, 173), post_str)
    except Exception as e:
        print("Failed make image", e)
        return {"ret": False, "error":"makeimage"}
    
    print("Image made, posting image..")
    
    #post the image
    try:
        cl.photo_upload(f"./imageMaker/temp/{post_str}.jpg", post_str)
    except:
        print("Failed to post image")
        with conn.cursor() as cur:
            cur.execute(f"DELETE FROM Posts WHERE PostID='{post_num}';")
            conn.commit()
        return {"ret": False, "error":"uploadfail"}
    
    #delete the img from temp
    os.remove(f"./imageMaker/temp/{post_str}.jpg")
    
    return {"ret": True, "post_num": post_num}

@app.route('/recents', methods=["GET"])
def recents():
    startid = int(request.args.get('startid'))
    
    if(startid is None):
        return {"ret": False, "error":"nostartid"}
    
    try:
        with conn.cursor() as cur:
            if(startid == -1):
                cur.execute("SELECT MAX(PostID) FROM Posts;")
                res = cur.fetchall()
                conn.commit()
                max_id = res[0][0]
            else:
                max_id = startid
                
            min_id = max( (max_id - 4) , 0)
            cur.execute(f"SELECT PostID,message,name FROM Posts WHERE PostID BETWEEN {min_id} AND {max_id};")
            res = cur.fetchall()
            conn.commit()
            
    except:
        print(f"Failed to get from db")
        return {"ret": False, "error":"dbfail"}
    
    return {"ret": True, "data": res}

if __name__ == "__main__":
    logger = logging.getLogger('waitress')
    logger.setLevel(logging.INFO)
    
    serve(app, host='0.0.0.0', port=80, threads=8)
    #app.run(host='0.0.0.0', port=80)